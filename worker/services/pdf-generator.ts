import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';
import type { RadarScanResult } from '../types';

export async function generatePDFReport(
  scanResult: RadarScanResult,
  url: string
): Promise<Uint8Array> {
  // Create PDF document
  const pdfDoc = await PDFDocument.create();
  const page = pdfDoc.addPage([595, 842]); // A4 size in points
  
  // Embed fonts
  const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
  const regularFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
  
  const { width, height } = page.getSize();
  let yPosition = height - 50;
  
  // Helper function to draw text
  const drawText = (text: string, size: number, font: typeof regularFont | typeof boldFont, color = rgb(0, 0, 0)) => {
    page.drawText(text, {
      x: 50,
      y: yPosition,
      size,
      font,
      color
    });
    yPosition -= size + 10;
  };
  
  // Header
  drawText('Cloudflare Radar URL Scan Report', 24, boldFont, rgb(0.4, 0.49, 0.92));
  yPosition -= 10;
  
  // Scan metadata
  drawText(`URL: ${url}`, 12, regularFont);
  drawText(`Scanned: ${new Date().toLocaleString()}`, 10, regularFont, rgb(0.4, 0.4, 0.4));
  drawText(`Scan ID: ${scanResult.task.uuid}`, 10, regularFont, rgb(0.4, 0.4, 0.4));
  yPosition -= 20;
  
  // Security Verdict Section
  drawText('Security Verdict', 16, boldFont);
  yPosition -= 5;
  
  const isMalicious = scanResult.verdicts?.overall?.malicious || false;
  const verdictText = isMalicious ? 'MALICIOUS' : 'SAFE';
  const verdictColor = isMalicious ? rgb(0.8, 0, 0) : rgb(0, 0.6, 0);
  drawText(verdictText, 14, boldFont, verdictColor);
  
  if (scanResult.verdicts?.overall?.categories?.length > 0) {
    drawText(`Categories: ${scanResult.verdicts.overall.categories.join(', ')}`, 10, regularFont);
  }
  
  if (scanResult.verdicts?.overall?.tags?.length > 0) {
    drawText(`Tags: ${scanResult.verdicts.overall.tags.join(', ')}`, 10, regularFont);
  }
  yPosition -= 20;
  
  // Page Information
  drawText('Page Information', 16, boldFont);
  yPosition -= 5;
  drawText(`Domain: ${scanResult.page.domain}`, 11, regularFont);
  drawText(`IP Address: ${scanResult.page.ip}`, 11, regularFont);
  drawText(`Country: ${scanResult.page.country}`, 11, regularFont);
  drawText(`ASN: ${scanResult.page.asn}`, 11, regularFont);
  drawText(`HTTP Status: ${scanResult.page.status}`, 11, regularFont);
  
  if (scanResult.page.title) {
    drawText(`Page Title: ${scanResult.page.title}`, 11, regularFont);
  }
  yPosition -= 20;
  
  // Technologies Detected
  if (scanResult.meta?.processors?.wappa?.data && scanResult.meta.processors.wappa.data.length > 0) {
    drawText('Technologies Detected', 16, boldFont);
    yPosition -= 5;
    
    const technologies = scanResult.meta.processors.wappa.data.slice(0, 10); // Top 10
    for (const tech of technologies) {
      const techText = `- ${tech.app} (${tech.categories.map(c => c.name).join(', ')})`;
      drawText(techText, 10, regularFont);
    }
    yPosition -= 20;
  }
  
  // Network Statistics
  drawText('Network Statistics', 16, boldFont);
  yPosition -= 5;
  drawText(`Total Requests: ${scanResult.data.requests?.length || 0}`, 11, regularFont);
  drawText(`Unique IPs: ${scanResult.stats.uniqIPs}`, 11, regularFont);
  drawText(`Unique Countries: ${scanResult.stats.uniqCountries}`, 11, regularFont);
  drawText(`Data Transferred: ${(scanResult.stats.dataLength / 1024).toFixed(2)} KB`, 11, regularFont);
  yPosition -= 20;
  
  // Domains Contacted
  if (scanResult.lists?.domains && scanResult.lists.domains.length > 0) {
    drawText('Domains Contacted', 16, boldFont);
    yPosition -= 5;
    
    const domains = scanResult.lists.domains.slice(0, 15); // Top 15
    for (const domain of domains) {
      if (yPosition < 100) {
        // Add new page if running out of space
        const newPage = pdfDoc.addPage([595, 842]);
        yPosition = height - 50;
        page.drawText = newPage.drawText.bind(newPage);
      }
      drawText(`- ${domain}`, 10, regularFont);
    }
    yPosition -= 20;
  }
  
  // Phishing Detection
  if (scanResult.meta?.processors?.phishing?.data && scanResult.meta.processors.phishing.data.length > 0) {
    drawText('Phishing Indicators', 16, boldFont, rgb(0.8, 0, 0));
    yPosition -= 5;
    
    for (const indicator of scanResult.meta.processors.phishing.data) {
      drawText(`WARNING: ${indicator}`, 10, regularFont, rgb(0.8, 0, 0));
    }
    yPosition -= 20;
  }
  
  // Footer
  yPosition = 50;
  page.drawText('Generated by Cloudflare Radar URL Scanner', {
    x: 50,
    y: yPosition,
    size: 8,
    font: regularFont,
    color: rgb(0.5, 0.5, 0.5)
  });
  
  page.drawText(`Report Date: ${new Date().toISOString()}`, {
    x: width - 250,
    y: yPosition,
    size: 8,
    font: regularFont,
    color: rgb(0.5, 0.5, 0.5)
  });
  
  // Save and return PDF as Uint8Array
  const pdfBytes = await pdfDoc.save();
  return pdfBytes;
}
